<!-- build time:Thu Apr 02 2020 09:36:42 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next pisces use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="google-site-verification" content="BgA1_hEEAsxNsl7oVpssww_0_1fVbHtL-vjQDzFJV5w"><meta name="baidu-site-verification" content="hI7th0hmOV"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="https://fonts.loli.net/css?family=Roboto Slab:300,300italic,400,400italic,700,700italicRoboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/header.jpg?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/header.jpg?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/header.jpg?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="算法,数据结构,动态规划,"><link rel="alternate" href="/atom.xml" title="WS的小屋" type="application/atom+xml"><meta name="description" content="前言的前言：本篇文章较长，请择需阅读，右边（或左边）有目录，我也根据内容对目录做了详细的划分，本文参考网上各大博客再加上自己的总结，将我认为最有用最容易理解的部分整合到了一起，希望对你有所帮助！前言：我好像突然对算法感兴趣 了，就好像高中的时候对数学比较难的题目感兴趣 ，果然兴趣很关键，之前对SpringBoot的快速搭建感兴趣研究了很长时间，但我原以为我不会喜欢这种类型的题目，现在却出于好奇心再"><meta property="og:type" content="article"><meta property="og:title" content="动态规划问题"><meta property="og:url" content="http://wsuo.top/posts/34462"><meta property="og:site_name" content="WS的小屋"><meta property="og:description" content="前言的前言：本篇文章较长，请择需阅读，右边（或左边）有目录，我也根据内容对目录做了详细的划分，本文参考网上各大博客再加上自己的总结，将我认为最有用最容易理解的部分整合到了一起，希望对你有所帮助！前言：我好像突然对算法感兴趣 了，就好像高中的时候对数学比较难的题目感兴趣 ，果然兴趣很关键，之前对SpringBoot的快速搭建感兴趣研究了很长时间，但我原以为我不会喜欢这种类型的题目，现在却出于好奇心再"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rKExs.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rKCa8.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rK0iD.png"><meta property="og:image" content="https://img-blog.csdnimg.cn/20200204184510783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1ruzrt.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rK9Vf.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rKSqP.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1ruxKI.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rKFPg.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rKPIS.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rKkGQ.png"><meta property="og:image" content="https://s2.ax1x.com/2020/02/05/1rKA2j.png"><meta property="article:published_time" content="2020-02-05T01:14:06.833Z"><meta property="article:modified_time" content="2020-02-05T02:00:23.782Z"><meta property="article:author" content="wsuo"><meta property="article:tag" content="算法"><meta property="article:tag" content="数据结构"><meta property="article:tag" content="动态规划"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s2.ax1x.com/2020/02/05/1rKExs.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Pisces",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!0,scrollpercent:!0,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://wsuo.top/posts/34462.html"><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"e12c868c"}),daovoice("update")</script><script src="https://neveryu.github.io/js/src/pace.min.js"></script><title>动态规划问题 | WS的小屋</title><meta name="generator" content="Hexo 4.2.0"></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><a href="https://github.com/wsuo" target="_blank" rel="noopener" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">WS的小屋</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">It is never too old to learn.</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-首页"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-我的简介"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>我的简介</a></li><li class="menu-item menu-item-博客标签"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>博客标签</a></li><li class="menu-item menu-item-文章分类"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>文章分类</a></li><li class="menu-item menu-item-归档"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-相册"><a href="/photo/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i><br>相册</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>Search</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="Searching..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://wsuo.top/posts/34462"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="wsuo"><meta itemprop="description" content=""><meta itemprop="image" content="/images/header.jpg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="WS的小屋"></span><header class="post-header"><h2 class="post-title" itemprop="name headline">动态规划问题</h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-05T09:14:06+08:00">2020-02-05 </time><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">Post modified&#58;</span> <time title="Post modified" itemprop="dateModified" datetime="2020-02-05T10:00:23+08:00">2020-02-05 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构和算法</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><span class="post-meta-item-text">评论：</span> <a href="/posts/34462#comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/posts/34462" itemprop="commentCount"></span> </a></span><span class="post-meta-divider">|</span> <span class="page-pv"><i class="fa fa-file-o"></i> <span class="busuanzi-value" id="busuanzi_value_page_pv"></span></span><div class="post-wordcount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">Words count in article&#58;</span> <span title="Words count in article">10.6k 字 </span><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span title="Reading time">41 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p><code>前言的前言：</code>本篇文章较长，请择需阅读，右边（或左边）有目录，我也根据内容对目录做了详细的划分，本文参考网上各大博客再加上自己的总结，将我认为最有用最容易理解的部分整合到了一起，希望对你有所帮助！</p><hr><p><code>前言：</code>我好像突然<del>对算法感兴趣</del> 了，就好像高中的时候<del>对数学比较难的题目感兴趣</del> ，果然兴趣很关键，之前对SpringBoot的快速搭建感兴趣研究了很长时间，但我原以为我不会喜欢这种类型的题目，现在却出于好奇心再加上一股倔劲，就是想把它搞明白，于是有了这篇博客。再加上最近在力扣刷题，但是之前从没有接触过算法题，有的看答案都看不懂，后来做的题做多了发现有好多类似的题目，所以我打算总结一下规律。</p><hr><blockquote><ul><li><p>声明：此篇博客为转载已有的文章并总结优化，仅供自己学习记录使用，如有侵权，联系删除，发表到网上也是想到会对大家学习理解动态规划有所帮助。</p></li><li><p>人无完人，设想地球上的每个超棒的想法都能汇聚在相应的小河之中，那么文明的大河将会迅速变成大海（赶在太阳将河水蒸干之前）。感谢互联网，让开源共享精神照耀了这个时代，让这个设想有了真正的可能。</p></li><li><p>如果你想了解更多可以去看文末的参考文章，我觉得他们讲的都特别好，此篇博客也参考了很多他们的内容。</p></li></ul></blockquote><h2 id="一、动态规划的思想"><a href="#一、动态规划的思想" class="headerlink" title="一、动态规划的思想"></a>一、动态规划的思想</h2><p>分享一个故事：</p><blockquote><p>来源：见底部参考文章</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A * <span class="string">"1+1+1+1+1+1+1+1 =？"</span> *</span><br><span class="line"></span><br><span class="line">A : <span class="string">"上面等式的值是多少"</span></span><br><span class="line">B : *计算* <span class="string">"8!"</span></span><br><span class="line"></span><br><span class="line">A : *在上面等式的左边写上 <span class="string">"1+"</span> *</span><br><span class="line">A : <span class="string">"此时等式的值为多少"</span></span><br><span class="line">B : *quickly* <span class="string">"9!"</span></span><br><span class="line">A : <span class="string">"你怎么这么快就知道答案了"</span></span><br><span class="line">A : <span class="string">"只要在8的基础上加1就行了"</span></span><br><span class="line">A : <span class="string">"所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"</span></span><br></pre></td></tr></table></figure><p><strong>动态规划算法的核心就是记住已经解决过的子问题的解。</strong></p><p>动态规划的思想和表达方式都非常简单，求一个问题的解，先得准确的找到该问题所包含的<code>重叠子问题</code>。</p><p>– 什么是重叠子问题？</p><blockquote><p>所谓重叠子问题，就是在求解原问题的解的过程中需要大量重复求解的子问题</p></blockquote><p>求出其重叠子问题的解并将其记录以备再次使用，这样可以大量削减搜索的开销，提高<code>时间复杂度</code>。</p><ul><li>态规划是在尝试了一个问题的每一种可能的解之后，再从中找出最优解。</li><li>动态规划是一种既保证正确性又非常高效的算法。</li></ul><hr><p>动态规划经典类型：(最后面会详细讲解背包问题)</p><ul><li>背包</li><li>树型</li><li>计数动态规划</li></ul><p>求解的方式: （后面有例题）</p><ul><li>a. 自顶向下的备忘录法</li><li>b. 自顶向上</li></ul><p>说了那么多理论,相信大家还是蒙的,好的,下面举栗子。</p><h2 id="二、动态规划的简单应用"><a href="#二、动态规划的简单应用" class="headerlink" title="二、动态规划的简单应用"></a>二、动态规划的简单应用</h2><p>下面是一个<strong>斐波那契数列</strong>的简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fib( n-<span class="number">1</span>)+fib(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入6</span></span><br><span class="line"><span class="comment">//输出：8</span></span><br></pre></td></tr></table></figure><blockquote><p>这段代码很简单吧，其实程序就是这样的，执行效率和编写效率永远是成反比的，更让人头疼的是公司只要执行效率（我管你编写有多难呢），这也是我们学习数据结构的原因（<del>应付面试与考研</del> ）。</p></blockquote><p>算法的执行流程是这样的：<br><img src="https://s2.ax1x.com/2020/02/05/1rKExs.png" alt="1rKExs.png"></p><blockquote><p>但凡遇到需要递归的问题，最好都画出递归树，这对你分析算法的复杂度，寻找算法低效的原因都有巨大帮助。</p></blockquote><p>这个递归树怎么理解？就是说想要计算原问题 f(20)，我就得先计算出子问题 f(19) 和 f(18)，然后要计算 f(19)，我就要先算出子问题 f(18) 和 f(17)，以此类推。最后遇到 f(1) 或者 f(2) 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p><hr><p>问：<strong>递归算法的时间复杂度怎么计算？</strong><br>答：<strong>子问题个数乘以解决一个子问题需要的时间。</strong></p><ul><li>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</li><li>解决一个子问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) 一个加法操作，时间为 O(1)。</li><li>所以，这个算法的时间复杂度为 O(2^n)，指数级别，爆炸。</li></ul><p>好了，有了栗子，我们看一下该怎么分析，怎么用动态规划处理它：</p><hr><p>我们先用第一种方法解决:</p><h5 id="a-自顶向下的备忘录法"><a href="#a-自顶向下的备忘录法" class="headerlink" title="a. 自顶向下的备忘录法"></a>a. 自顶向下的备忘录法</h5><p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 f(4) 被计算了两次，而且你可以看到，以 f(4) 为根的这个递归树体量又大，多算一遍，会耗费巨大的时间。更何况，还不止 f(4) 这一个节点被重复计算，所以这个算法及其低效。</p><hr><p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p><hr><p>那么问题是怎么判断有没有存过呢？</p><ul><li>先给数组赋初值</li><li>如果循环的时候发现不等于这个初值了，就说明已经存过了</li><li>然后返回这个值，就免去了一次遍历</li></ul><p>这就是备忘录法的大致思想。下面我们用<code>java</code>代码实现以下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//新建一个数组用于存储计算过的值</span></span><br><span class="line">        <span class="keyword">int</span>[] Memo = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始值的判断</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给数组赋初值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Memo[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fib2(n, Memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> Memo[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不等于初值-1了,说明已经计算过了</span></span><br><span class="line">        <span class="keyword">if</span> (Memo[n] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Memo[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            Memo[n] = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Memo[n] = fib2(n-<span class="number">1</span>, Memo) + fib2(n-<span class="number">2</span>, Memo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Memo[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p></blockquote><p>我们还有一个问题：<br>Q：递归算法的时间复杂度怎么算？<br>A：子问题个数乘以解决一个子问题需要的时间。</p><hr><ul><li>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1), f(2), f(3) ... f(6)</code>，数量和输入规模 n = 6<code>成正</code>比，所以子问题个数为 O(n)。</li><li>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</li><li>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</li></ul><blockquote><p>至此，带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做<code>「自顶向下」</code>，动态规划叫做<code>「自底向上」</code>。</p></blockquote><p>那么问题来了：</p><hr><p>啥叫「自顶向下」？</p><p>注意我们刚才画的递归树（或者说图），是从上向下延伸，都是<code>从一个规模较大</code>的原问题比如说 f(6)，<code>向下逐渐分解</code>规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案，这就叫「自顶向下」。</p><p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始<code>往上推</code>，直到推到我们想要的答案 f(6)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p><h5 id="b-自底向上的动态规划"><a href="#b-自底向上的动态规划" class="headerlink" title="b. 自底向上的动态规划"></a>b. 自底向上的动态规划</h5><p>上面的解法还是用到了递归，计算最大的元素的时候还是要回过头去计算最小的，只是只计算一次了，那为什么不能直接从最小的开始算呢？下面我们就来实现一下自底向上的方法：</p><blockquote><p>这也就是动态规划的核心，先计算子问题，再由子问题计算父问题。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] Memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        Memo[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        Memo[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Memo[n] = Memo[n-<span class="number">1</span>] + Memo[n-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Memo[n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>自底向上方法也是利用数组保存了先计算的值，为后面的调用服务。观察参与循环的只有 <code>i，i-1 , i-2</code>三项，因此该方法的空间可以进一步的压缩如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib4</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> Memo_i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> Memo_i_1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> Memo_i_2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Memo_i = Memo_i_2 + Memo_i_1;</span><br><span class="line">            Memo_i_2 = Memo_i_1;</span><br><span class="line">            Memo_i_1 = Memo_i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> Memo_i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>一般来说由于备忘录方式的动态规划方法使用了递归，递归的时候会产生额外的开销，使用<code>自底向上</code>的动态规划方法要比备忘录方法好。</li><li>你以为看懂了上面的例子就懂得了动态规划吗？那就too young too simple了。动态规划远远不止如此简单。</li></ul><hr><p>这里再介绍一种自己总结的解决问题很好的方法：</p><h3 id="动态规划的三大步骤"><a href="#动态规划的三大步骤" class="headerlink" title="动态规划的三大步骤"></a>动态规划的三大步骤</h3><h4 id="1、定义数组元素的含义"><a href="#1、定义数组元素的含义" class="headerlink" title="1、定义数组元素的含义"></a>1、定义数组元素的含义</h4><blockquote><p>就是你要求什么。</p></blockquote><ul><li>我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？</li></ul><p>这里斐波那契数列元素仅仅代表数字，很容易理解，但有的题目就很难理清楚。</p><h4 id="2、找出数组元素之间的关系式"><a href="#2、找出数组元素之间的关系式" class="headerlink" title="2、找出数组元素之间的关系式"></a>2、找出数组元素之间的关系式</h4><blockquote><p>就是往后退一步，看他是怎么求出来的。</p></blockquote><ul><li>我觉得动态规划，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 <code>dp[n]</code> 时，是可以利用 <code>dp[n-1]，dp[n-2].....dp[1]</code>，来推出 dp[n] 的，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 <code>dp[n] = dp[n-1] + dp[n-2]</code>，这个就是他们的<code>关系式</code>了。而这一步，也是最难的一步。</li></ul><p>这里斐波那契数列的关系式就是<code>dp[n] = dp[n-1] + dp[n-2]</code>;</p><h4 id="3、找出初始值"><a href="#3、找出初始值" class="headerlink" title="3、找出初始值"></a>3、找出初始值</h4><blockquote><p>就是看看那个是不能通过公式求出来的。</p></blockquote><ul><li>学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 <code>dp[n] = dp[n-1] + dp[n-2]</code>，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 <code>dp[3] = dp[2] + dp[1]</code>。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是所谓的初始值。</li></ul><p>这里斐波那契数列的第一项和第二项也就是<code>dp[0]=0</code>和<code>dp[1]=1</code>是初始值,所有的数据都是基于他们两个得出来的，如果你仔细看那张图你会发现，最底层永远是这两个初始值。</p><hr><p>好了，目前为止我们的引言案例已经介绍完了，带你体验一下动态规划，让你对它感兴趣，下面步入正题：</p><h3 id="案例详解"><a href="#案例详解" class="headerlink" title="案例详解"></a>案例详解</h3><h4 id="1-案例一：简单的一维-DP"><a href="#1-案例一：简单的一维-DP" class="headerlink" title="1. 案例一：简单的一维 DP"></a>1. 案例一：简单的一维 DP</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><p>声明一下：我们这里不做那种特别难的题目，因为没什么意义，我们只是入门而已，如果你对这个算法感兴趣，可以去<a href="https://leetcode-cn.com/u/wsuo/" target="_blank" rel="noopener">Leelcode</a>找一些题目做做。</p><hr><p>好了,看这道题目，耗时根据我们的3步骤来解决这道题目，这道题相较于斐波那契数列抽象了一点，需要我们自己从题目中分析条件：</p><h5 id="1-定义数组元素的含义：你要求什么"><a href="#1-定义数组元素的含义：你要求什么" class="headerlink" title="1.定义数组元素的含义：你要求什么"></a>1.定义数组元素的含义：你要求什么</h5><p>按我上面的步骤说的，首先我们来定义 <code>dp[i]</code> 的含义，我们的问题是要求青蛙跳上 <code>n</code> 级的台阶总共由多少种跳法，那我们就定义 dp[i] 的含义为：<code>跳上一个 i 级的台阶总共有 dp[i] 种跳法</code>。这样，如果我们能够算出 dp[n]，不就是我们要求的答案吗？</p><blockquote><p><code>求什么设什么</code>，好熟悉啊，这也是我们做数学应用题的时候用的方法。</p></blockquote><p>所以第一步定义完成。</p><h5 id="2-找出数组元素之间的关系式：往后退一步"><a href="#2-找出数组元素之间的关系式：往后退一步" class="headerlink" title="2.找出数组元素之间的关系式：往后退一步"></a>2.找出数组元素之间的关系式：往后退一步</h5><p>我们的目的是要求 <code>dp[n]</code>，动态规划的题就是把一个规模比较大的问题分成几个规模比较小的问题，然后由小的问题推导出大的问题。也就是说，dp[n] 的规模为 <code>n</code>，比它规模小的是 <code>n-1, n-2, n-3....</code> 也就是说，dp[n] 一定会和 dp[n-1], dp[n-2]….存在某种关系的。我们要找出他们的关系。</p><p><strong>那么问题来了，怎么找？</strong></p><p>这个是动态规划问题中最为核心也是最难的部分。我们必须<code>回到问题本身</code>来了，来寻找他们的关系式，dp[n] 究竟会等于什么呢？</p><blockquote><p>对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式</p></blockquote><ul><li>一种是从第 n-1 级跳上来</li><li>一种是从第 n-2 级跳上来</li></ul><p>但是我们是要算<code>所有可能的</code>跳法的，所以有 ==dp[n] = dp[n-1] + dp[n-2]==。</p><p><strong>分而治之</strong>！！！体会到了没有，因为dp[n-1]也有两种情况:</p><ul><li>一种是从第 <code>n-1</code>-1 级跳上来</li><li>一种是从第 <code>n-1</code>-2 级跳上来</li></ul><p>是不是又绕回去了?<br>对,这就是<strong>思想的核心</strong>。</p><h5 id="3-找出初始值：找出公式求不出的值"><a href="#3-找出初始值：找出公式求不出的值" class="headerlink" title="3.找出初始值：找出公式求不出的值"></a>3.找出初始值：找出公式求不出的值</h5><p>当 n = 1 时，<code>dp[1] = dp[0] + dp[-1]</code>，而我们是数组是不允许下标为负数的，所以对于 dp[1]，我们必须要<code>直接给出它的数值</code>，相当于初始值，显然，<code>dp[1] = 1</code>。一样，<code>dp[0] = 0</code>.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：</p><p><code>dp[0] = 0</code>. <code>dp[1] = 1</code>.</p><p>即 n &lt;= 1 时，dp[n] = n.</p><p>这样对吗？</p><p>我们不妨试一下，将2代进去，当有两个台阶的时候有几种跳法？</p><blockquote><p>两种！ 一种是一次跳一个跳两次，一种是跳两个一步到位。</p></blockquote><p>这么说<code>dp[2]=2</code>;</p><p>但是公式得出的是：dp[2] = dp[0] + dp[1] = 0 + 1 = 1;</p><p>所以在寻找初始值的时候，一<strong>定要注意不要找漏了</strong>，dp[2] 也算是一个初始值，不能通过公式计算得出。</p><ul><li>Q: 有什么办法能避免这种错误吗?</li><li>A: 有，很简单，多做几道题你就会了。</li><li>Q: 。。。。</li></ul><hr><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">( <span class="keyword">int</span> n )</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 先创建一个数组来保存历史数据</span></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 给出初始值</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 通过关系式来计算出 dp[n]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把最终结果返回</span></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-案例二：二维数组的-DP"><a href="#2-案例二：二维数组的-DP" class="headerlink" title="2. 案例二：二维数组的 DP"></a>2. 案例二：二维数组的 DP</h4><blockquote><p>80% 的题，都是要用二维数组的，所以下面的题主要以二维数组为主。</p></blockquote><ul><li>Q：要用一维还是二维，我怎么知道？</li><li>A：这个问题不大，接着往下看。</li></ul><p><strong>问题描述</strong>：<br>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？<br><img src="https://s2.ax1x.com/2020/02/05/1rKCa8.png" alt="1rKCa8.png"></p><p><img src="https://s2.ax1x.com/2020/02/05/1rK0iD.png" alt="1rK0iD.png"></p><h5 id="1-定义数组元素的含义：你要求什么-1"><a href="#1-定义数组元素的含义：你要求什么-1" class="headerlink" title="1. 定义数组元素的含义：你要求什么"></a>1. 定义数组元素的含义：你要求什么</h5><p>这个应该不难想出来含义应该是<strong>dp[i][j] = 从起点出发到达第<code>i,j</code>位置的路径条数</strong></p><blockquote><p>这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 <code>dp[m-1] [n-1]</code> 就是我们要找的答案。</p></blockquote><h5 id="2-找出数组元素间的关系式：往后退一步"><a href="#2-找出数组元素间的关系式：往后退一步" class="headerlink" title="2. 找出数组元素间的关系式：往后退一步"></a>2. 找出数组元素间的关系式：往后退一步</h5><p>想象以下，机器人要怎么样才能到达 (i, j) 这个位置？<br><code>从终点往后退一步再看</code>。<br>由于机器人只能向下走或者向右走，所以有两种方式到达</p><ul><li>一种是从 <code>(i-1, j)</code> 这个位置走一步到达</li><li>一种是从 <code>(i, j-1)</code> 这个位置走一步到达</li></ul><p>因为是计算所有可能的步骤，所以是把所有可能走的路径都<code>加起来</code>，所以关系式是 <code>dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]</code>。</p><p>加起来这个字眼很重要，只要有<strong>总的</strong>，<strong>全部</strong>，<strong>和</strong>、这些字眼的题目，我们要立刻想到<strong>加起来</strong>。</p><h5 id="3-找出初始值：公式求不出的值"><a href="#3-找出初始值：公式求不出的值" class="headerlink" title="3. 找出初始值：公式求不出的值"></a>3. 找出初始值：公式求不出的值</h5><p>其实你只要把关系式写出来了，初始值就自然而然的出来了，你只需要看哪个数字是公式<code>求不出来的</code>，或者说那个数字是<code>不能代进去的</code>。</p><p>显然，当 <code>dp[i] [j]</code> 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 <code>i - 1</code> 或者 <code>j - 1</code>，就变成负数了，数组就会出问题了。所以我们就是要求这个<code>不能用公式求出来的值</code>来作为初始值。</p><p>所以我们的初始值是计算出所有的 <code>dp[0] [0….n-1]</code> 和所有的 <code>dp[0….m-1] [0]</code>。这个还是非常容易计算的，相当于计算图中的<strong>第一行</strong>和<strong>第一列</strong>。</p><p>因此初始值如下：</p><ul><li><code>dp[0] [0….n-1] = 1;</code> // 相当于最上面一行，机器人只能一直往右走</li><li><code>dp[0…m-1] [0] = 1;</code> // 相当于最左面一列，机器人只能一直往下走</li></ul><p>好了，现在三个步骤都走完了，是不是<del>很简单</del> 呢？</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推导出 dp[m-1][n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>空间复杂度: <code>O(n*m)</code></p></blockquote><p>其实算法这种东西，代码不是很重要，重要的是思维。你实现的方式有很多种，但是<code>思维和方法</code>能想到一个就不错了。</p><hr><h4 id="3-案例三：二维数组-DP"><a href="#3-案例三：二维数组-DP" class="headerlink" title="3. 案例三：二维数组 DP"></a>3. 案例三：二维数组 DP</h4><p><img src="https://img-blog.csdnimg.cn/20200204184510783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk0MTM2NA==,size_16,color_FFFFFF,t_70" alt="案例三"><br>摘自<a href="https://leetcode-cn.com/problems/minimum-path-sum/" target="_blank" rel="noopener">Leelcode-64</a>题；</p><h5 id="1-定义数组元素的含义：你要求什么-2"><a href="#1-定义数组元素的含义：你要求什么-2" class="headerlink" title="1. 定义数组元素的含义：你要求什么"></a>1. 定义数组元素的含义：你要求什么</h5><p>由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i] [j]的含义为：当机器人从左上角走到<code>(i, j)</code> 这个位置时，最小的路径和是 <code>dp[i] [j]</code>。那么，<code>dp[m-1] [n-1]</code> 就是我们要的答案了。</p><blockquote><p>这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 由下角的位置是 <code>(m-1, n - 1)</code>，所以 <code>dp[m-1] [n-1]</code> 就是我们要走的答案。</p></blockquote><h5 id="2-找出数组元素之间的关系式：往后退一步-1"><a href="#2-找出数组元素之间的关系式：往后退一步-1" class="headerlink" title="2. 找出数组元素之间的关系式：往后退一步"></a>2. 找出数组元素之间的关系式：往后退一步</h5><p>往后退一步，要怎么样才能走到 (i, j) 这个位置？有两种方式：</p><ul><li>一种是从 <code>(i-1, j)</code> 这个位置到达</li><li>一种是从<code>(i, j-1)</code> 这个位置到达</li></ul><p>不过这次不是计算所有可能路径，而是计算哪一个<code>路径和是最小的</code>，那么我们要从这两种方式中，选择一种，使得<code>dp[i] [j]</code> 的值是最小的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] [j] = min(dp[i-<span class="number">1</span>][j]，dp[i][j-<span class="number">1</span>]) + arr[i][j];<span class="comment">// arr[i][j] 表示网格中的值</span></span><br></pre></td></tr></table></figure><h5 id="3-找出初始值：公式求不出的值-1"><a href="#3-找出初始值：公式求不出的值-1" class="headerlink" title="3. 找出初始值：公式求不出的值"></a>3. 找出初始值：公式求不出的值</h5><p>谁求不出？<code>i</code>和<code>j</code>中有一个为零都不行，所以我们的初始值是计算出所有的 <code>dp[0] [0….n-1]</code> 和所有的 <code>dp[0….m-1] [0]</code>。</p><blockquote><p>这里的<code>0….m-1</code>可以换算成<code>1...m</code>，也就是1到<code>i</code>，这里分析出来的<code>dp[0….m-1] [0]</code>就是你代码中要<code>代入公式</code><strong>初始化</strong>写在左边的。</p></blockquote><p>因此初始值如下：</p><ul><li><code>dp[0] [j] = arr[0] [j] + dp[0] [j-1];</code></li><li><code>dp[i] [0] = arr[i] [0] + dp[i-1] [0];</code></li></ul><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span>[][] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = arr.length;</span><br><span class="line">    <span class="keyword">int</span> n = arr[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n]; <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 初始化最左边的列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + arr[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化最上边的行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] + arr[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">// 推导出 dp[m-1][n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]) + arr[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="4-案例四：编辑距离"><a href="#4-案例四：编辑距离" class="headerlink" title="4. 案例四：编辑距离"></a>4. 案例四：编辑距离</h4><p>来源：<a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">Leelcode-72. 编辑距离</a>;</p><p><strong>问题描述：</strong><br>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: word1 = <span class="string">"horse"</span>, word2 = <span class="string">"ros"</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: </span><br><span class="line">horse -&gt; rorse (将 <span class="string">'h'</span> 替换为 <span class="string">'r'</span>)</span><br><span class="line">rorse -&gt; rose (删除 <span class="string">'r'</span>)</span><br><span class="line">rose -&gt; ros (删除 <span class="string">'e'</span>)</span><br></pre></td></tr></table></figure><p><strong>让我们来干掉这一题：</strong></p><blockquote><p>90% 的字符串问题都可以用动态规划解决，并且90%是采用二维数组。</p></blockquote><h5 id="1-定义数组元素的含义：你要求什么-3"><a href="#1-定义数组元素的含义：你要求什么-3" class="headerlink" title="1. 定义数组元素的含义：你要求什么"></a>1. 定义数组元素的含义：你要求什么</h5><p>我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 <code>dp[i] [j]</code>的含义为：<strong>当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 <code>dp[i] [j]</code>。</strong></p><h5 id="2-找出数组元素之间的关系式：往后退一步-2"><a href="#2-找出数组元素之间的关系式：往后退一步-2" class="headerlink" title="2. 找出数组元素之间的关系式：往后退一步"></a>2. 找出数组元素之间的关系式：往后退一步</h5><p>接下来我们就要找 dp[i] [j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，<code>dp[i] [j]</code> 和 <code>dp[i-1] [j]</code>、<code>dp[i] [j-1]</code>、<code>dp[i-1] [j-1]</code> 肯定存在某种关系。</p><p>这里先把题目的条件拉过来：</p><ul><li>插入一个字符</li><li>删除一个字符</li><li>替换一个字符</li></ul><p>还有第一步我们分析的结果：</p><blockquote><p>当字符串 word1 的长度为 <code>i</code>，字符串 word2 的长度为 <code>j</code> 时，将 word1 转化为 word2 所使用的最少操作次数为 <code>dp[i] [j]</code>。</p></blockquote><p>也就是说：</p><ul><li>如果是在<code>字符串</code>word1末尾插入一个与 word2[j] 相等的<code>字符</code>就能使它符合条件,<strong>(注意这里的word1是字符串,word2[j]是字符)</strong>,那么在这个操作之前，word1后面肯定是少一个字母的，所以将 word1 转化为 word2 所使用的最少操作次数应该是将 <code>后面少一个字母的word1</code> 转化为 word2 所使用的最少操作次数再加上本次操作，也就是加1，翻译成代码就是：<code>dp[i] [j] = dp[i-1] [j] + 1</code>；因为i-1代表的是长度嘛；</li><li>如果是在<code>字符串</code>word1末尾删除一个<code>字符</code>就能使它符合条件,那么在这个操作之前，word1后面肯定是多一个字母的，所以将 word1 转化为 word2 所使用的最少操作次数应该是将 <code>后面多一个字母的word1</code> 转化为 word2 所使用的最少操作次数再加上本次操作，也就是加1，翻译成代码就是：<code>dp[i] [j] = dp[i] [j-1] + 1</code>；</li><li>如果把字符 word1[i] 替换成与 word2[j] 相等，意思就是将这两个字符串的最后一个字符交换一下就可以了，那交换之前呢？交换之前的最少操作此时肯定是dp[i-1][j-1]，因为我们忽略了最后一个元素了，所以翻译成代码就是：<code>dp[i] [j] = dp[i-1] [j-1] + 1;</code></li></ul><p>我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] [j] = min(dp[i-<span class="number">1</span>] [j-<span class="number">1</span>]，dp[i] [j-<span class="number">1</span>]，dp[[i-<span class="number">1</span>] [j]]) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>于是，我们的关系式就推出来了。</p><h5 id="3-找出初始值：公式求不出的值-2"><a href="#3-找出初始值：公式求不出的值-2" class="headerlink" title="3. 找出初始值：公式求不出的值"></a>3. 找出初始值：公式求不出的值</h5><p>看看哪个是公式求不出的，<code>i</code>和<code>j</code>两个都不能等于0,所以求不出的就是他俩有一个等于零的时候，也就是所有的<code>dp[0] [0….n]</code> 和所有的 <code>dp[0….m] [0]</code>；</p><blockquote><p>这里的<code>0….m-1</code>可以换算成<code>1...m</code>，也就是1到<code>i</code>，这里分析出来的<code>dp[0….m-1] [0]</code>就是你代码中要<code>代入公式</code><strong>初始化</strong>写在左边的。</p></blockquote><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dp[0][0...n2]的初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">     	dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// dp[0...n1][0] 的初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过公式推出 dp[n1][n2]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span></span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你要练习，可以去 leetcode，选择动态规划专题，然后连续刷几十道，保证你以后再也不怕动态规划了。<del>当然，遇到很难的，咱该挂的还是得挂。</del></p><p>OKOKOKOKOOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOKOK</p><hr><p>到现在为止你已经是一名动态规划初级选手了，要想进阶到中级选手必须<a href="https://wsuo.github.io/" target="_blank" rel="noopener">充钱</a><br>[狗头]。</p><p>开玩笑的，要想进阶必须学习<del>油画</del> ！！！<br>呸，<strong>优化</strong>。</p><h3 id="另一种思路"><a href="#另一种思路" class="headerlink" title="另一种思路"></a>另一种思路</h3><p>好了，我相信这种思路你已经掌握了，我们还有另一种思路解决问题，就是我在前面提到的——两种方法：</p><ul><li>自顶向下的备忘录法</li><li>自底向上的动态规划</li></ul><p>我们前面用到的三大步骤都是：<code>自底向上的动态规划。</code></p><p>你可以用备忘录法自己实现一下，这里就不展开了，留给你自己做。</p><hr><h2 id="三、动态规划的经典模型"><a href="#三、动态规划的经典模型" class="headerlink" title="三、动态规划的经典模型"></a>三、动态规划的经典模型</h2><h3 id="1-线性模型"><a href="#1-线性模型" class="headerlink" title="1. 线性模型"></a>1. 线性模型</h3><p>线性模型的是动态规划中最常用的模型，这里的线性指的是状态的排布是呈线性的。我们常用一维数组解题。具体的概念就不展开了，感兴趣的可以再去Google一下什么是线性模型。</p><h3 id="2-区间模型"><a href="#2-区间模型" class="headerlink" title="2. 区间模型"></a>2. 区间模型</h3><p>区间模型基本就是二维空间模型，我们常用二维数组解题，就像我们前面的案例二到案例四都是<code>区间模型</code></p><blockquote><p>区间模型的状态表示一般为d[i][j]，表示区间[i, j]上的最优解，然后通过状态转移计算出[i+1, j]或者[i,j+1]上的最优解，逐步扩大区间的范围，最终求得[1, len]的最优解。</p></blockquote><h3 id="3-背包模型：（较难，可跳过）"><a href="#3-背包模型：（较难，可跳过）" class="headerlink" title="3. 背包模型：（较难，可跳过）"></a>3. 背包模型：（较难，可跳过）</h3><p>背包问题是动态规划中一个最典型的问题之一。</p><hr><blockquote><p>前两个模型我们都有讲到，但是背包模型还没有提到，那么现在我们对背包模型进行详细的讲解。</p></blockquote><p>我们这里用最简单的例子来解决背包问题：</p><p>这里使用<code>动态转移方程</code>：<br>这里第一次提这个概念，相信你也听到过这个概念，你可能也会感到奇怪为什么文章中自始至终都没有提呢，到最后才说？</p><hr><p>因为我本人不太喜欢用这个词语，不过它的使用我已经体现过了，其实他就是我们求得 <code>数组元素之间的关系式</code> 再加上 <code>初始值</code>，把这两个式子结合起来就是所谓的<code>动态转移方程</code>。</p><p>我觉得吧，关键是理解，他叫什么不重要，你看，我不跟你说什么是动态转移方程也就那么着，你也不会去想他是什么，只要你理解了，无论用什么方法只要能做出来题目，我们的目的也就达到了。</p><hr><p>我们这里直接给出背包的状态转换方程：<br><img src="https://s2.ax1x.com/2020/02/05/1ruzrt.png" alt="1ruzrt.png"></p><ul><li>先确定含义：<code>m[i,W]</code>表示在前i件物品中选择若干件放在承重为 W 的背包中，可以取得的最大价值。</li><li>Vi表示第i件物品的价值。</li><li>决策：为了背包中物品总价值最大化，第 i件物品应该放入背包中吗 ？</li></ul><p><img src="https://s2.ax1x.com/2020/02/05/1rK9Vf.png" alt="1rK9Vf.png"><br><strong>问题描述：</strong><br>假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。</p><hr><p>也就是说有编号分别为a,b,c,d,e的五件物品，它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包，如何让背包里装入的物品具有最大的价值总和？</p><p><img src="https://s2.ax1x.com/2020/02/05/1rKSqP.png" alt="1rKSqP.png"></p><ul><li>只要你能通过找规律手工填写出上面这张表就算理解了01背包的动态规划算法。</li><li>这张表是至底向上，从左到右生成的。</li><li>为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。</li><li>对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的。</li><li>同理，c2=0，b2=3,a2=6。</li><li>对于承重为8的背包，a8=15,是怎么得出的呢？</li></ul><p>根据01背包的状态转换方程，需要考察两个值：<br><img src="https://s2.ax1x.com/2020/02/05/1ruxKI.png" alt="1ruxKI.png"><br>一个是：<img src="https://s2.ax1x.com/2020/02/05/1rKFPg.png" alt="1rKFPg.png"></p><p>另一个是：<br><img src="https://s2.ax1x.com/2020/02/05/1rKPIS.png" alt="1rKPIS.png"></p><ul><li><code>m[i-1,W]</code>表示我有一个承重为8的背包，当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值</li><li><code>m[i-1,W-wi]</code>表示我有一个承重为6的背包（等于当前背包承重减去物品a的重量），当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值</li><li><code>m[i-1,W-wi]</code>就是指单元格b6,值为9，<code>vi</code>指的是a物品的价值，即6</li><li>由于<code>m[i-1,W-wi]</code>+<code>vi</code> = 9 + 6 = 15 大于<code>m[i-1,W]</code>= 9，所以物品a应该放入承重为8的背包</li></ul><p>好，就讲到这，代码也不给了，感兴趣的自己可以去查阅相关书籍资料。</p><blockquote><p>背包问题有很多特别难的题目，我们浅尝辄止，毕竟只是入门。</p></blockquote><hr><h2 id="三、动态规划的优化"><a href="#三、动态规划的优化" class="headerlink" title="三、动态规划的优化"></a>三、动态规划的优化</h2><blockquote><p>Q：那我该咋优化呢？<br>A：当然是画图了</p></blockquote><p>没错，<code>80%</code> 的动态规划题都可以画图，其中 <code>80%</code> 的题都可以通过画图一下子知道怎么优化，当然，DP 也有一些很难的题，想优化可没那么容易，不过，今天我要讲的，是属于不怎么难，且最常见，面试笔试最经常考的难度的题。</p><hr><h3 id="优化案例"><a href="#优化案例" class="headerlink" title="优化案例"></a>优化案例</h3><h4 id="1-案例一：最多路径数"><a href="#1-案例一：最多路径数" class="headerlink" title="1. 案例一：最多路径数"></a>1. 案例一：最多路径数</h4><p>也就是第二章节的案例二，如果你懒得翻，好吧，我贴在下面：</p><p>这道题的 dp 转移公式是 <code>dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]</code></p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 推导出 dp[m-1][n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们当时是这个亚子实现的，不过他的空间复杂度是<code>O(n * m)</code>，是可以优化的：</p><h5 id="优化案例一"><a href="#优化案例一" class="headerlink" title="优化案例一"></a>优化案例一</h5><p>首先<code>dp[i] [j]</code> 是一个二维矩阵，我们来画个二维矩阵的图，对矩阵进行初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>1</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>1</td><td>*</td><td>*</td><td>*</td></tr><tr><td>1</td><td>*</td><td>*</td><td>*</td></tr><tr><td>1</td><td>*</td><td>*</td><td>*</td></tr></tbody></table><p>然后根据公式 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> 来填充矩阵的其他值。下面我们先填充第二行的值。</p><table><thead><tr><th>1</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>1</td><td>*</td><td>*</td><td>*</td></tr><tr><td>1</td><td>*</td><td>*</td><td>*</td></tr></tbody></table><blockquote><p>当我们要填充第三行的值的时候，我们需要用到第一行的值吗？答是不需要的，当你要填充第三，第四….第 n行的时候，第一行的值永远不会用到，只要填充第二行的值时会用到。</p></blockquote><p>根据公式 <code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>，我们可以知道，当我们要计算第 i 行的值时，除了会用到第 <code>i-1</code> 行外，其他第 1 至 第 <code>i-2</code> 行的值我们都是不需要用到的，<strong>那对于那部分用不到的值我们还有必要保存他们吗？</strong></p><p><strong>没必要</strong>，我们只需要用一个一维的 <code>dp[]</code> 来保存一行的历史记录就可以了。然后在计算的过程中，不断的更新 <code>dp[]</code> 的值。</p><p>估计你可能不好理解，下面我就手把手来演示下这个过程。</p><hr><ol><li>刚开始初始化第一行，此时 dp[0..n-1] 的值就是第一行的值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">3</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>1</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr></tbody></table><ol start="2"><li>接着我们来一边填充第二行的值一边更新 dp[i] 的值，一边把第一行的值抛弃掉。</li></ol><blockquote><p>为了方便描述，下面我们用<code>arr (i，j)</code>表示矩阵中第 i 行 第 j 列的值。从 0 开始，就是说有第 0 行。</p></blockquote><ul><li>显然，矩阵(1, 0) 的值相当于以往的初始化值，为 1。然后这个时候矩阵 (0，0）的值不在需要保存了，因为再也用不到了。</li></ul><table><thead><tr><th>*</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>1</td><td>*</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr></tbody></table><ul><li>这个时候，我们也要跟着更新 <code>dp[0]</code> 的值了，刚开始 <code>dp[0] = (0, 0)</code>，现在更新为 <code>dp[0] = (1, 0)</code> 。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//第二行的第一个元素</span></span><br></pre></td></tr></table></figure><ul><li>接着继续更新 (1, 1) 的值，根据之前的公式 <code>（i, j）= (i-1, j) + (i, j- 1)</code>。即 （1，1）=（0，1）+（1，0）=2。</li></ul><table><thead><tr><th>*</th><th>1</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">1</span>; --&gt; dp[<span class="number">1</span>] = <span class="number">2</span>; <span class="comment">//根据公式更新,由第一行转到第二行,第一行的抛弃掉</span></span><br></pre></td></tr></table></figure><p>以往的二维的时候， <code>dp[i][j] = dp[i-1] [j]+ dp[i][j-1]</code>。现在转化成一维，不就是 <code>dp[i] = dp[i] + dp[i-1]</code> 吗？</p><p>即 dp[1] = dp[1] + dp[0]，而且还动态帮我们更新了 dp[1] 的值。因为刚开始 dp[i] 的保存第一行的值的，<code>现在更新为</code>保存第二行的值。</p><table><thead><tr><th>*</th><th>*</th><th>1</th><th>1</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr></tbody></table><ol start="3"><li>同样的道理，按照这样的模式一直来计算第二行的值，顺便把第一行的值抛弃掉，结果如下：</li></ol><table><thead><tr><th>*</th><th>*</th><th>*</th><th>*</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>4</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//由第二行更新至第一行</span></span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">dp[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">dp[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">dp[<span class="number">3</span>] = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>此时，dp[i] 将<code>完全保存着第二行</code>的值，并且我们可以推导出公式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i]</span><br><span class="line"><span class="comment">//注意</span></span><br><span class="line">dp[i-<span class="number">1</span>] 相当于之前的 dp[i-<span class="number">1</span>][j]，dp[i] 相当于之前的 dp[i][j-<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><ol start="4"><li>于是按照这个公式不停着填充到最后一行，结果如下：</li></ol><table><thead><tr><th>*</th><th>*</th><th>*</th><th>*</th></tr></thead><tbody><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>*</td><td>*</td><td>*</td><td>*</td></tr><tr><td>1</td><td>4</td><td>10</td><td>20</td></tr></tbody></table><p>最后 <code>dp[n-1]</code> 就是我们要求的结果了。所以优化之后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      dp[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 第 i 行第 0 列的初始值</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 公式：dp[i] = dp[i-1] + dp[i]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            dp[j] = dp[j-<span class="number">1</span>] + dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-案例二：编辑距离"><a href="#2-案例二：编辑距离" class="headerlink" title="2. 案例二：编辑距离"></a>2. 案例二：编辑距离</h4><p>也就是第二章节的案例四，如果你懒得翻，好吧，我也贴在下面：</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dp[0][0...n2]的初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">     	dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// dp[0...n1][0] 的初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过公式推出 dp[n1][n2]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span></span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               dp[i][j] = Math.min(Math.min(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], dp[i][j - <span class="number">1</span>]), dp[i - <span class="number">1</span>][j]) + <span class="number">1</span>;</span><br><span class="line">            &#125;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题的关系式是：<br><code>dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;</code></p><h5 id="优化案例二"><a href="#优化案例二" class="headerlink" title="优化案例二"></a>优化案例二</h5><ul><li>对于这道题其实也是一样的，如果要计算 第 i 行的值，我们最多只依赖第 i-1 行的值，不需要用到第 i-2 行及其以前的值，所以一样可以采用一维 dp 来处理的。</li><li>不过这个时候要注意，在上面的例子中，我们每次更新完 (i, j) 的值之后，就会把 (i, j-1) 的值抛弃，也就是说之前是一边更新 dp[i] 的值，一边把 dp[i] 的旧值抛弃的，不过在这道题中则不可以，因为我们还需要用到它。</li></ul><hr><ol><li>当我们要计算图中 (i,j) 的值的时候，在案例1 中，我们值需要用到 (i-1, j) 和 (i, j-1)。（看图中方格的颜色）<br><img src="https://s2.ax1x.com/2020/02/05/1rKkGQ.png" alt="1rKkGQ.png"></li><li>不过这道题中，我们还需要用到 （i-1, j-1) 这个值（但是这个值在以往的案例1 中，它会被抛弃掉）<br><img src="https://s2.ax1x.com/2020/02/05/1rKA2j.png" alt="1rKA2j.png"><br>所以呢，对于这道题，我们还需要一个额外的变量 pre 来时刻保存 <code>(i-1,j-1)</code> 的值。推导公式就可以从二维的</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = min(dp[i-<span class="number">1</span>][j] , dp[i-<span class="number">1</span>][j-<span class="number">1</span>] , dp[i][j-<span class="number">1</span>]) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>转化为一维的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = min(dp[i-<span class="number">1</span>], pre, dp[i]) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>所以呢，案例2 其实和案例1 差别不大，就是多了个变量来临时保存。</p><p>最终代码如下：</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistance</span><span class="params">(String word1, String word2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = word1.length();</span><br><span class="line">    <span class="keyword">int</span> n2 = word2.length();</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n2 + <span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dp[0...n2]的初始值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n2; j++) </span><br><span class="line">        dp[j] = j;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// dp[j] = min(dp[j-1], pre, dp[j]) + 1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 相当于初始化</span></span><br><span class="line">        dp[<span class="number">0</span>] = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++) &#123;</span><br><span class="line">            <span class="comment">// pre 相当于之前的 dp[i-1][j-1]</span></span><br><span class="line">            <span class="keyword">int</span> pre = temp;</span><br><span class="line">            temp = dp[j];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1</span></span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i - <span class="number">1</span>) == word2.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[j] = pre;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               dp[j] = Math.min(Math.min(dp[j - <span class="number">1</span>], pre), dp[j]) + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 保存要被抛弃的值       </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n2]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h4 id="1-解法总结"><a href="#1-解法总结" class="headerlink" title="1. 解法总结"></a>1. 解法总结</h4><p>为什么动态规划的解法看起来如此精妙，是因为动态规划遵循一套固定的流程：</p><ul><li>递归的暴力解法</li><li>带备忘录的递归解法</li><li>非递归的动态规划解法（关键）</li></ul><p>用我们的方法就是：</p><ul><li>定义数组元素的含义</li><li>找出数组元素之间的关系式</li><li>找出初始值</li></ul><p>通俗一点就是：</p><ul><li>你要求什么</li><li>往后退一步</li><li>公式求不出的值</li></ul><hr><h4 id="2-作者总结"><a href="#2-作者总结" class="headerlink" title="2. 作者总结"></a>2. 作者总结</h4><blockquote><p>上面的这些题，基本都是不怎么难的入门题，除了最后一道相对难一点。并且基本 80% 的二维矩阵 dp 都可以像上面的方法一样优化成一维矩阵的dp，核心就是要画图，看他们的值依赖，当然，还有很多其他比较难的优化，但是，我遇到的题中，大部分都是我上面这种类型的优化。</p></blockquote><p>所以说，看完我写的这篇文章是一个什么水平呢？毫不夸张的说，你对于动态规划乃至于算法已经<code>入门</code>了，恭喜，以后还有更多更难的题目等着你，更多关于技术的分享文章，请<a href="https://wsuo.github.io/" target="_blank" rel="noopener">点击</a>。</p><p>最后谢谢你的观看。</p><hr><p>参考文章：<br><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">1、力扣：72.编辑距离</a><br><a href="https://leetcode-cn.com/problems/unique-paths/" target="_blank" rel="noopener">2、力扣：62.不同路径</a><br><a href="https://juejin.im/post/5d556b7ef265da03aa2568d5#heading-8" target="_blank" rel="noopener">3、动态规划套路详解</a><br><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">4、算法-动态规划 Dynamic Programming–从菜鸟到老鸟</a><br><a href="https://zhuanlan.zhihu.com/p/91582909?utm_source=qq&utm_medium=social&utm_oi=1116438468829691904" target="_blank" rel="noopener">5、告别动态规划，连刷 40 道题，我总结了这些套路，看不懂你打我</a><br><a href="https://blog.csdn.net/mu399/article/details/7722810" target="_blank" rel="noopener">6、动态规划之01背包问题（最易理解的讲解）</a><br><a href="https://zhuanlan.zhihu.com/p/30959069" target="_blank" rel="noopener">7、0-1背包问题的动态规划算法</a></p><hr></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div>觉得文章对您有帮助请我喝杯奶茶吧^_^</div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>Donate</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/uploads/wxpay.png" alt="wsuo WeChat Pay"><p>WeChat Pay</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/uploads/alipay.jpg" alt="wsuo Alipay"><p>Alipay</p></div></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author:</strong> wsuo</li><li class="post-copyright-link"><strong>Post link:</strong> <a href="http://wsuo.top/posts/34462" title="动态规划问题">http://wsuo.top/posts/34462</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> unless stating additionally.</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"><i class="fa fa-tag"></i> 算法</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag"><i class="fa fa-tag"></i> 动态规划</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/9149" rel="next" title="论坛术语"><i class="fa fa-chevron-left"></i> 论坛术语</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/51649" rel="prev" title="IDEA 2020 破解方法">IDEA 2020 破解方法 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#一、动态规划的思想"><span class="nav-number">1.</span> <span class="nav-text">一、动态规划的思想</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二、动态规划的简单应用"><span class="nav-number">2.</span> <span class="nav-text">二、动态规划的简单应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#a-自顶向下的备忘录法"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">a. 自顶向下的备忘录法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#b-自底向上的动态规划"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">b. 自底向上的动态规划</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#动态规划的三大步骤"><span class="nav-number">2.1.</span> <span class="nav-text">动态规划的三大步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、定义数组元素的含义"><span class="nav-number">2.1.1.</span> <span class="nav-text">1、定义数组元素的含义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、找出数组元素之间的关系式"><span class="nav-number">2.1.2.</span> <span class="nav-text">2、找出数组元素之间的关系式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、找出初始值"><span class="nav-number">2.1.3.</span> <span class="nav-text">3、找出初始值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#案例详解"><span class="nav-number">2.2.</span> <span class="nav-text">案例详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-案例一：简单的一维-DP"><span class="nav-number">2.2.1.</span> <span class="nav-text">1. 案例一：简单的一维 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-定义数组元素的含义：你要求什么"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1.定义数组元素的含义：你要求什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-找出数组元素之间的关系式：往后退一步"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">2.找出数组元素之间的关系式：往后退一步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-找出初始值：找出公式求不出的值"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">3.找出初始值：找出公式求不出的值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-案例二：二维数组的-DP"><span class="nav-number">2.2.2.</span> <span class="nav-text">2. 案例二：二维数组的 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-定义数组元素的含义：你要求什么-1"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">1. 定义数组元素的含义：你要求什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-找出数组元素间的关系式：往后退一步"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">2. 找出数组元素间的关系式：往后退一步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-找出初始值：公式求不出的值"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">3. 找出初始值：公式求不出的值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-案例三：二维数组-DP"><span class="nav-number">2.2.3.</span> <span class="nav-text">3. 案例三：二维数组 DP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-定义数组元素的含义：你要求什么-2"><span class="nav-number">2.2.3.1.</span> <span class="nav-text">1. 定义数组元素的含义：你要求什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-找出数组元素之间的关系式：往后退一步-1"><span class="nav-number">2.2.3.2.</span> <span class="nav-text">2. 找出数组元素之间的关系式：往后退一步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-找出初始值：公式求不出的值-1"><span class="nav-number">2.2.3.3.</span> <span class="nav-text">3. 找出初始值：公式求不出的值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-案例四：编辑距离"><span class="nav-number">2.2.4.</span> <span class="nav-text">4. 案例四：编辑距离</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-定义数组元素的含义：你要求什么-3"><span class="nav-number">2.2.4.1.</span> <span class="nav-text">1. 定义数组元素的含义：你要求什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-找出数组元素之间的关系式：往后退一步-2"><span class="nav-number">2.2.4.2.</span> <span class="nav-text">2. 找出数组元素之间的关系式：往后退一步</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-找出初始值：公式求不出的值-2"><span class="nav-number">2.2.4.3.</span> <span class="nav-text">3. 找出初始值：公式求不出的值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#另一种思路"><span class="nav-number">2.3.</span> <span class="nav-text">另一种思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、动态规划的经典模型"><span class="nav-number">3.</span> <span class="nav-text">三、动态规划的经典模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-线性模型"><span class="nav-number">3.1.</span> <span class="nav-text">1. 线性模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-区间模型"><span class="nav-number">3.2.</span> <span class="nav-text">2. 区间模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-背包模型：（较难，可跳过）"><span class="nav-number">3.3.</span> <span class="nav-text">3. 背包模型：（较难，可跳过）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三、动态规划的优化"><span class="nav-number">4.</span> <span class="nav-text">三、动态规划的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优化案例"><span class="nav-number">4.1.</span> <span class="nav-text">优化案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-案例一：最多路径数"><span class="nav-number">4.1.1.</span> <span class="nav-text">1. 案例一：最多路径数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优化案例一"><span class="nav-number">4.1.1.1.</span> <span class="nav-text">优化案例一</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-案例二：编辑距离"><span class="nav-number">4.1.2.</span> <span class="nav-text">2. 案例二：编辑距离</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优化案例二"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">优化案例二</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#四、总结"><span class="nav-number">5.</span> <span class="nav-text">四、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-解法总结"><span class="nav-number">5.0.1.</span> <span class="nav-text">1. 解法总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-作者总结"><span class="nav-number">5.0.2.</span> <span class="nav-text">2. 作者总结</span></a></li></ol></li></div></div></section><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span><span class="with-love" id="animate" style="font-size:13px"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">wangshuo</span></div><div id="days"></div><script>function show_date_time(){window.setTimeout("show_date_time()",1e3),BirthDay=new Date("02/02/2020 20:02:02"),today=new Date,timeold=today.getTime()-BirthDay.getTime(),sectimeold=timeold/1e3,secondsold=Math.floor(sectimeold),msPerDay=864e5,e_daysold=timeold/msPerDay,daysold=Math.floor(e_daysold),e_hrsold=24*(e_daysold-daysold),hrsold=setzero(Math.floor(e_hrsold)),e_minsold=60*(e_hrsold-hrsold),minsold=setzero(Math.floor(60*(e_hrsold-hrsold))),seconds=setzero(Math.floor(60*(e_minsold-minsold))),document.getElementById("days").innerHTML="本站已安全运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒"}function setzero(e){return 10>e&&(e="0"+e),e}show_date_time()</script><div class="busuanzi-count"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="site-uv"><i class="fa fa-user"></i> <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> </span><span class="site-pv"><i class="fa fa-eye"></i> <span class="busuanzi-value" id="busuanzi_value_site_pv"></span></span></div><div style="font-family:STLiti;display:inline-block;height:20px;line-height:20px"><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?spm=5176.12825654.7y9jhqsfz.112.ec712c4akg7qpK&aly_as=ADQQ5jnw"><img src="/images/gov.png" style="float:left">浙公网安备330031520005106</a> <span class="post-meta-divider" style="color:#555">|</span><span><a href="http://www.miitbeian.gov.cn" target="_blank">浙ICP备20005106号-1</a></span></div></div></footer></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script type="text/javascript">var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: true,
        appId: '1Eu9zO3L7hMHe42v0OSjLzCB-gzGzoHsz',
        appKey: 'jVs3QBUljb0042G0RSRUugB6',
        placeholder: 'talk with me',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });</script><script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var t=$("#local-search-input");t.attr("autocapitalize","none"),t.attr("autocorrect","off"),t.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(t){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(t,e,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:t,dataType:isXml?"xml":"json",async:!0,success:function(t){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,r=document.getElementById(e),s=document.getElementById(o),a=function(){var t=r.value.trim().toLowerCase(),e=t.split(/[\s\-]+/);e.length>1&&e.push(t);var o=[];if(t.length>0&&n.forEach(function(n){function r(e,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===t&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(t,e){var o="",n=e.start;return e.hits.forEach(function(e){o+=t.substring(n,e.position);var r=e.position+e.length;o+='<b class="search-keyword">'+t.substring(e.position,r)+"</b>",n=r}),o+=t.substring(n,e.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url),d=[],g=[];if(""!=l&&(e.forEach(function(t){function e(t,e,o){var n=t.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(e=e.toLowerCase(),t=t.toLowerCase());(s=e.indexOf(t,r))>-1;)a.push({position:s,word:t}),r=s+n;return a}d=d.concat(e(t,h,!1)),g=g.concat(e(t,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(t){t.sort(function(t,e){return e.position!==t.position?e.position-t.position:t.word.length-e.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hits.length!==e.hits.length?e.hits.length-t.hits.length:t.start-e.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(t){b+="<a href='"+f+'\'><p class="search-result">'+s(p,t)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===e.length&&""===e[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x" /></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>';else{o.sort(function(t,e){return t.searchTextCount!==e.searchTextCount?e.searchTextCount-t.searchTextCount:t.hitCount!==e.hitCount?e.hitCount-t.hitCount:e.id-t.id});var a='<ul class="search-result-list">';o.forEach(function(t){a+=t.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(t){t.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(t){t.stopPropagation()}),$(document).on("keyup",function(t){var e=27===t.which&&$(".search-popup").is(":visible");e&&onPopupClose()})</script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/javascript" src="/js/src/clipboard.min.js"></script><script type="text/javascript" src="/js/src/clipboard-use.js"></script><script type="text/javascript" src="/js/src/love.js"></script></body></html><!-- rebuild by neat -->